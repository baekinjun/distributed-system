1장 분산시스템의 약속과 위험 

1.1 단일 서버의 한계

서버는 데이터를 저장하고 사용자 요청을 처리하며 CPU,메모리,네트워크,디스크를 사용해 계산을 수행 네가지 물리자원원은 어떤 컴퓨팅에도 필수적이다.

사용자 요청을 처리하는 단일서버의 용량은 결국 네가지 주요 자원의 한계에 따라 결정된다.

디스크의 성능은 읽기나 쓰기 작업의 종류와 디스크 캐시를 얼마나 잘 활용하는지에 따라 달라진다.

이미지 찾기

CPU나 메모리가 한계에 도달하면 요청은 처리순서를 기다려야하며 이때 큐잉이 발생한다.

1.2 비즈니스 로직과 데이터 계층의 분리 

비저장 컴포넌트
  사용자에게 기능을 제공하는 역할을 하는 부분
  웹 API 형태로 구현된다.

상태저장 컴포넌트 
  데이터베이스가 관리

이미지 찾기

대다수 애플리케이션 로직은 독립된 네가지 자원을 활용하는 별도서버에서 실행된다.
  사용자 대다수에게 각기 다른 계층의 캐시로 서비스를 제공하면 더욱 잘동작
  하지만 데이터베이스 계층까지 도달하는 요청수가 급격히 증가하면 문제가 생기는데 이는 데이터베이스의 물리적 제약 때문이다.

1.3 데이터 파티션하기

하드웨어가 물리적 한계에 도달했을때 소프트웨어 시스템 요청을 제대로 처리하기 위해서는 데이터를 나누어 여러서버에 처리하게 하는것이다.

1.4 실패 살펴보기

실패는 데이터를 다룰때 어려워진다. 임의의 서버에서 데이터를 다루는 독립된 인스턴스를 만드는 작업은 간단하지 않다.

일부 컴포넌트가 실패에 발생해도 시스템의 기능을 유지라혀면 클러스터를 구성하여 여러 노드에 분산하는것으론 부족하고 효과적으로 실패를 잘 숨기는 전략이 매우중요

1.5 복제:실패 숨기기
복제는 실패를 숨기고 서비스의 가용성을 보장할때 중요한 역할을 한다.

소프트웨어는 실패를 감지하고 사용자에게 불일치가 보이지 않게해야한다. 

1.5.1 프로세스 죽음 

사용자가 서버에 데이터를 저장 성공에 응답을 받으면 프로세스가 재시작한 뒤에도 데이터의 사용을 보장하는것은 매우중요하다.

프로세스의 죽음을 처리하고 데이터의 무결성 과 가용성을 보장하는 조치가 필요하다.

1.5.2 네트워크 지연

TCP/IP 프로토콜은 비동기 방식으로 동작하여 메세지 전달 지연시간을 알수 없는데 이때 지정한 시간내에 응답이 오지 않으면 재시도 혹은 실패할지 판단이 중요
  이 판단은 프로세스간 통신의 신뢰성과 효율성을 유지관리 하는데 매우 중요

1.5.3 프로세스 일시 정지

프로세스는 언제든 일시 정지 할수 있으므로 다른 프로세스들이 일시정지한 프로세스가 실패했는지 여부를 판단해야한다.

1.5.4 동기화 되지않은 시계

네트워크 결함이 생겨 서버시계가 동기화가 되지않으면 프로세스 메세지를 정렬하거나 저장된 데이터의 시퀀스를 결정할때 일관성이 깨질수 있다.

1.6 분산 시스템의 정의

분산시스템
  상호 연결된 여려 노드 및 서버가 서로 협력해 공통의 목표를 달성하는 소프트웨어 아키텍처
  작업 부하를 여러서버에 분산해 병렬 처ㄹ와 성능 향상을 이룬다.

1.7 패턴 접근법

적어도 세 개의 시스템에서 관찰되어야 패턴으로 인정한다.

2장 패턴 개요

2.1 단일 서버에서 데이터를 견고하게 유지하기

그림 보기(2.3)

쓰기전 로그를 사요하면 불일치 문제를 효과적으로 해결할수 있다.
  메시지 처리자는 갱신이 필요한 정보를  로그파일에 먼저 쓴다.
  이과정은 단일 쓰기라서 원자적 수행 보장하기 쉽다.
  다른 노드가 죽더라도 어떤일이 일어났는지 파악하기 쉽다.

로그는 복원력을 제공 한다.
  특정한 이전 상태가 주어진 경우 로그에 선형적으로 기록된 변경 사항들을 이용해 로그가 실행된 최종 상태를 알수있다.
  데이터베이스는 앞의 예제 에서 설명한 쓰기 로그를 사용해 트랜잭션 구현

2.2 갱신 경쟁

음수 같은 불일치 문제 해결 가장 쉬운 접근법 리더팔로워 
  노드 하나를 리더로 지정하고 다른 노드들은 팔로워로 간주한다.
  리더가 모든 갱신을 처리하고 갱신내용을 팔로워에게 퍼뜨린다.
  그림 보기(2.7 , 2.8)

2.3 리더 실패 다루기 

하트비트
  노드에게는 동료 노드와 연결에 문제가 있는지 확인할때
  노드간에 정기적으로 보내는 메세지로 노드가 살아있고 통신이 가능하지 확인
  하트비트를 받지 못하면 새리더를 뽑기 위한 선거 진행

노드들이 서로 상태가 다를때 리더는 쓰기 전 로그에 변경사항을 기록하고 해당 로그 엔트리를 
팔로워에게 복사하는것으로 복제를 처리해 팔로워들이 로그 엔트리를 검토해 올바른 상태가 무엇인지 알아낼수있다.

클러스터 노드의 과반을 의미하는 과반수 정족수가 로그메시지 복제에 성공했다면 한 노드가 리더와 연결이 끊기더라도 
클러스터가 일관성을 유지 관리할 것이라 확신

2.4 다중실패는 세대 시계가 필요하다.

리더가 죽고 다른 리더가 선출되고 다시 리더가 되었을떄 어떤 요청을 선택해야하는지 알수없다.

세대 시계(generation clock) 을 사용
  리더를 선출 할떄마다 증가하는 숫자로 리더 팔로워의 핵심요건이다.

다시 리더가 된 노드(넵튠)는 클라이언트 요청을 처리하기 전에 가용할수 있는 모든 노드의 로그를 확인해 과반수 정족수에 복제 되지 않은 엔트가 있는지 검사한다.
  이런 엔트리는 데이터에 적용되지 않았기 떄문에 언커밋이라 한다.

충돌이 발생하는 경우에는 안전하게 더 높은 세대의 엔트리를 선택한다.
그림(2.18) 보기

넵튠은 자신의 로그에 언커밋 엔트리를 현재세대 번호로 덮어쓰고 주피터(2세대 리더) 에 복제 진행한다.

주피터가 리더가 되었을때 이전 리더인 넵튠이 일시적으로 끊겼다가 돌아와 주피터와 새턴에게 요청을 보낼떄는 어떻게 할까?

세대시계가 매우 유용
  모든 요청에는 세대 시계를 덧붙여 클러스터 노드에 전송 
  모든 노드는 항상 더높은 세대의 요청을 선택하고 낮은 세대 요청 거절
  그림(2.19) 보기

2.5 로그엔트리는 과반수 정족수를 얻기 전까지 커밋할수 없다.

클러스터의 과반수 정족수에 복제되지 않았다면 다른 엔트리로 덮어쓸수있다.
  리더는 요청을 자신의 로그에 추가한후 곧바로 데이터 저장소에 적용할수 없고 다른 노드에서 확인응답을 충분히 받을때 까지 기다려야한다.
  갱신이 로컬 로그에 추가되면 리더는 과반수 정족수 만큼 응답을 받을때까지 언커밋 상태로 있다가 그후에 커밋
  그림 (2.20) 보기

과반수 정족수가 중요한 이유는 클러스터의 의사 결정에 적용되기 때문에 노드가 실패했을 경우 모든 리더 선출에는 과반수 정족수가 참여해야한다.

로그가 너무크면 리더 선출을 위해 노드간에 로그를 이동하는 비용이 많이들수있는데 이때 복제로그에 많이 사용하는 래프트 알고리즘을 사용해
가장 최신의 로그가 있는 노드를 선택해 리더로 설정하여 비용최소화

2.6 팔로워는 하이 워터마크를 기준으로 커밋한다.

리더는 과반수 정족수만큼 확인응답을 받으면 커밋한다.

팔로워는 언제 커밋?

하이워터마크 
  리더가 유지 관리 가장 최신의 갱신 인덱스이다.
  리더는 하트비트에 하이워터 마크를 추가한다.
  팔로워는 하트비트를 받을때마다 하이 워터마크까지 모든 로그 엔트리를 커밋할수있다. 

하트비트는 팔로워에게 하이 워터마크를 갱신하라고 알리는 신호이다.
그림(2.22 ~2.26) 보기

2.7 리더는 많은 클라이언트에게 빠르게 반응하기 위해 여러 큐를 사용한다.

갱신은 쓰기 전 로그로 보존이 필요한대 이는 내구성이 있는 저장소에 기록한다는 의미

내구성이있다 라는 말은 느리다 라는 뜻을 포함

여러 스레드가 동시에 같은 데이터를 갱신하려고 해도 문제가 없어야 한다.
로그가 모두 기록된 각각의 엔트리는 다른 엔트리를 쓰기전에 기록과 처리가 완료가 필요 
하지만 클라이언트는 기다리는것을 원하지 않는다.

이런이유로 단일 갱신 큐 사용

메시지 처리자는 클러스터가 복제를 수행하면서도 과반수 정족수에 도달하는 동안에도 요청처리를 할수 있게된다.

블록하는 대신 각각의 요청을 작업 큐에 넣기 전에 요청 대기목록에 등록해 대기하고 있는 요청을 추적하고 요청을 실제로 실행하면 클라이언트에게 응답
리더가 요청을 받으면 요청에 콜백을 붙여 대기 목록에 추가 
그림(2.27 ~ 2.30)

클라이언트에게 확인 응답전 실패하면 클라이언트가 요청을 재시도 하는데 문제가 발생할수있다.
  동일한 요청을 두번 전송할수 있음

동일 요청을 막기위해 각각의 클러스터 노드는 멱등 수신자로 구현되어야 한다.
  구현하기 위해 각각의 클라이언트는 요청전 자신을 리더에게 등록 
  등록한 클라이언트는 각각의 요청에 고유 번호를 부여한다.
  서버는 클라이언트ID 와 고유 요청번호를 사용해 실행한 요청의 응답을 저장 가능 
  반복 요청이 오면 요청을 다시 실행하는 대신 매핑을 참조해 저장된 응답 반환
  그림(2.31 ~ 2.33)

정렬된 로그를 복제할떄 메시지가 올바른 순서로 도착한다는 보장이 없다해도 순서보장이 필요

래프트 알고리즘은 오버헤드가 추가 발생해 성능을 떨어뜨림 

리더와 팔로워 사이에에서 노드들이 단일소켓 채널을 유지관리
  주키퍼, 아파치카프카 

2.8 팔로워는 리더의 읽기 요청 부하를 줄일 수 있다.

핫백업
  문제가 발생할때 팔로워가 리더를 대체
  팔로워로 하여금 읽기 요청을 처리하도록 팔로워 읽기
  리더의 부하를 줄여 더 빠르게 쓰기요청을 할수 있다.

문제점 
  팔로워는 로그 복제가 전파되는 시간만큼 리더의 상태가 뒤처진다.
  예전 데이터를 읽을 위험이 있다.

자신이 쓴 값 읽기 일관성 
  기록한것과 일치하는 데이터를 읽도록 보장 

버전화 방법
  레코드에 버전번호를 함께 저장하는 방법 

2.9 방대한 양의 데이터는 여러 노드에 파티션 할 수 있다.

파티션 구성 핵심요소
  데이터를 클러스터의 모든노드에 고르게 분산
  특정 데이터 레코드를 어떤 클러스터 노드가 저장하고 있는지 전체 노드에 요청하지 않고 알아야한다.
  일부 데이터를 새로운 노드로 빠르고 쉽게 옮길수 있어야한다.

대량의 데이터를 다룰 때 모든 데이터 레코드를 이동해서는 안된다.

그래서 논리 파티션을 사용

고정 파티션 (가장 간단한 형태)
  논리 파티션을 노드수의 열배로 설정하도록 권장한다.
  클라이언트 라이브러리는 클러스터 노드에 파티션을 매핑하는 정보를 가져와 초기화한다.
  간단한 나머지 연산을 통해 파티션을 찾고 요청을 전달한다.
  간단히 생성 가능하지만 범위 질의는 제한적 

키 범위 파티션 
  범위의 속하는 키 요소를 파티션 선택 알고리즘 일부로 사용
  키의 범위를 미리 알수없다는 점에서 어려움이 따른다.

데이터 시스템의 대부분은 단일 파티션으로 시작해 특정 크기에 도달하면 파티션을 분할한다.

2.10 파티션은 복제로 복원력을 제공한다.

클러스터 노드 하나가 실패하면 그노드에 호스팅된 모든 파티션은 사용할수 없게된다.

파티션 복제는 파티션하지 않은 데이터를 복제하는 방법과 같다.
  이전에 복제로그를 중심으로 설명한 복제패턴을 사용
  복제본이 많을수록 과반수 정족수가 커져 갱신에 응답속도가 느려짐
  * 복제본 세대 또는 다섯대가 내결함성과 성능 사이에서 적절한 균형수치

2.11 파티션간 일관성을 유지 관리 하려면 최소 두 단계가 필요하다.

복제로그는 복제본 문제를 해결하지만 파티션 간에 일관성을 유지 관리하는데는 도움이 되지않음 

2단계 커밋(2phase commit) 으로 해결가능 
  노드 하나를 코디네이터로 지정 - 작업의 첫번째 키를 호스팅하는 노드를 코디네이터로 지정한다.
  코디네이터는 트랜잭션의 상태를 모두 기록(정보는 디스크에 유지되어야한다.)
  진행되는 트랜잭션 정보를 영구적으로 보관하기 위해 쓰기전 로그를 유지관리한다.
  코디네이터는 다른 노드의 트랜잭션을 커밋하기 위한 조정을 수행 다른 노드는 코디네이터에게 스인했다는 메세지를 보내고 
  모든 데이터 저장소가 트랜잭션을 승인한 후에야 코디네이터는 트랜잭션을 커밋하고 응답
  참여하는 각각의 참가자는 자신의 복제로그를 유지 관리 여기에는 코디네이터 와 각각의 파티션을 위해 복제한 로그가 포함된다.
  그림(2.42~2.43)

2.12 분산 시스템에서 순서는 시스템 타임스템프에 의존해서는 안된다.

일관성 있게 읽으려면 갱신이 발생하는 순서를 결정하는 일은 중요하다.

단일노드에서는 카운터를 증가시키면 쉽게 구현가능 
  하지만 레코드를 여러노드에 걸쳐 저장하면 추적하는일이 까다로워진다.

타임스템프
  시간동기화 도구를 아무리 정밀하게 사용한다하더라도 여러 노드사이에서는 미세한 시차가 발생한다.
  노드간에 시간이 달라서 다른 메시지를 요청에 응답할수있다.

렘포트 시계
  타임스템프에 의존하지안않고 정수 카운터를 사용하여 요청순서를 추적
  레코드를 갱신할때마다 카운터 증가 
  문제는 타임스탬프와 상관없이 버전을 정수로 추적 따라서 특정 스냅샷요청시 확일할수 있는 방법이 없음
  더 큰 문제는 서로다른 두 서버에있는 데이터를 독립적인 클라이언트가 수정할떄 그 버전을 순서대로 나열할수가 없다.

하이브리드 시계
  타임스템프와 램포트 시계를 결합
  자신의 시계보다 더 앞선 타임스템프를 가진 메시지를 받으면 하이브리드 시계의 정수카운터 부분을 증가시키고 자신의 작업이 수신메시지보다 늦게 정렬되도록 보장한다.
  문제의 일부만 해결 부분순서 문제가 해결되지 않음 

시계제한대기
  값을 저장하기 전에 일정시간 대기해 클러스터 내 모든 노드의 시계가 해당 레코드에 할당된 타임스탬프를 충분히 지나도록 보장한다.
  스큐가 5초면 모든 쓰기 작업은 최대 5초동안 기다렸다가 값을 저장한다.
  이 접근법은 전체 노드가 최대 시계 스큐까지 기다리므로 클러스터 노드에서 어떤 요청이 시작되더라도 각자의 시곗값에 상관없이 최신값 보기를 보장받는다.

대다수 오픈소스 데이터베이스는 쓰기 작업에서 대기를 피하기 위해 읽기 재시작이라는 기법을 사용한다.







